You are an AI coding assistant working in VS Code inside my GitHub project ColorPalette.

I already created a JavaScript file at:
	‚Ä¢	js/getColorPalette.js

This file contains a working JavaScript implementation of the color palette extraction logic. You may either:
	‚Ä¢	Import and use it directly, or
	‚Ä¢	Treat it as a reference and create a TypeScript version (recommended) in an appropriate place (e.g. lib/getColorPalette.ts), with proper type definitions.

Do not delete the JS file; it‚Äôs an example/backup.

Your task:
	1.	Set up a Next.js + TypeScript app in this repo using pnpm.
	2.	Build a single-page React UI to:
	‚Ä¢	Load and display an image.
	‚Ä¢	Allow the user to tweak palette extraction parameters.
	‚Ä¢	Call the color palette function(s).
	‚Ä¢	Display the resulting palette visually with swatches and text overlays.
	3.	Update README.md with pnpm-based setup, run, and usage instructions.

‚∏ª

‚úÖ Project Setup Requirements
	‚Ä¢	Initialize a standard Next.js project with TypeScript in this repository.
	‚Ä¢	Use the classic pages/ router (not the app/ router) unless you have a strong reason to prefer app. If you do choose app, make sure the structure is consistent and clearly reflected in README.md.
	‚Ä¢	Use pnpm as the package manager.

Project should include:
	‚Ä¢	package.json
	‚Ä¢	pnpm-lock.yaml
	‚Ä¢	next.config.js
	‚Ä¢	tsconfig.json
	‚Ä¢	pages/_app.tsx
	‚Ä¢	pages/index.tsx
	‚Ä¢	styles/globals.css
	‚Ä¢	public/ folder (for any static assets)

In package.json, make sure the scripts include:

{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  }
}

Use TypeScript + React functional components with hooks.

‚∏ª

üé® Palette Utility Code (TypeScript)

You have two options; pick one and implement it cleanly:
	1.	Option A (recommended): Create a TypeScript port of the existing logic.
	‚Ä¢	Create lib/getColorPalette.ts (or a similar path under src or lib).
	‚Ä¢	Re-implement the functions from js/getColorPalette.js in TypeScript.
	‚Ä¢	Add proper type annotations and interfaces, for example:

        export interface PaletteColor {
            paletteColor: string;
            textColor: string;
            population: number;
            percentage: number;
        }

        export function getColorPaletteFromImageElement(
            img: HTMLImageElement,
            paletteSize?: number,
            maxResolution?: number,
            sampleStep?: number,
            nearDuplicateThreshold?: number
        ): Promise<PaletteColor[]>;

	‚Ä¢	Keep the same behavior: downsampling, quantization, optional near-duplicate merging, population/percentage calculation, best text color, etc.
	‚Ä¢	You may copy the logic from js/getColorPalette.js and adapt it to TS with types.

	2.	Option B: Import the existing JS directly.
	‚Ä¢	You can create a TypeScript declaration file (e.g. js/getColorPalette.d.ts) that declares the shape of the exported functions so TS can type-check calls.
	‚Ä¢	Then, import from "../js/getColorPalette" in your React components.
	‚Ä¢	This is acceptable but less ideal than a full TS port.

Whichever approach you pick, document it briefly in comments and do not remove js/getColorPalette.js.

‚∏ª

üñº UI Requirements (pages/index.tsx)

Create a single main page component that includes:

1. Header
	‚Ä¢	A simple, clear title: for example, ‚ÄúColor Palette Playground‚Äù.
	‚Ä¢	A short description line about what the tool does.

2. Image Upload & Preview
	‚Ä¢	A file input:

    <input type="file" accept="image/*" />

    ‚Ä¢	When a file is selected:
        ‚Ä¢	Use FileReader to convert it into a base64 data URL.
        ‚Ä¢	Store that data URL in React state.
	‚Ä¢	Display the image:

        <img
            id="previewImage"
            src={imageDataUrl}
            alt="Preview"
            ref={imgRef}
            style={{ maxWidth: "100%", height: "auto", borderRadius: "4px" }}
        />

    ‚Ä¢	Use useRef<HTMLImageElement | null> for the <img> element so it can be passed to getColorPaletteFromImageElement.
	‚Ä¢	All processing should be client-side only; no backend upload is needed.

3. Controls Panel (Sliders + Number Inputs)

Create a control panel with the following parameters, each having both:
	‚Ä¢	A slider (<input type="range" />)
	‚Ä¢	A synced numeric input (<input type="number" />)

Parameters and defaults:

Name | State key | Default | Slider Range
Palette Size | paletteSize | 8 | 1‚Äì32 | 
Max Resolution | maxResolution | 1024 | 256‚Äì2048 (step ~64)
Sample Step | sampleStep | 4 | 1‚Äì16
Near Duplicate Threshold | nearDuplicateThreshold | 30 | 0‚Äì100

	‚Ä¢	The slider and numeric input for each setting must stay in sync.
	‚Ä¢	Use React state with proper TypeScript types (e.g. number).
	‚Ä¢	Next to sampleStep, show a short helper text like:
Larger values are faster but less precise (samples fewer pixels).
	‚Ä¢	Next to nearDuplicateThreshold, show helper text like:
Higher values merge more similar colors into one swatch.

4. Generate Palette Button
	‚Ä¢	Add a button: ‚ÄúGenerate Palette‚Äù.
	‚Ä¢	On click:
	‚Ä¢	Ensure:
	‚Ä¢	An image has been loaded (imageDataUrl not null).
	‚Ä¢	The imgRef.current is a non-null HTMLImageElement.
	‚Ä¢	Call:

    const palette = await getColorPaletteFromImageElement(
        imgRef.current,
        paletteSize,
        maxResolution,
        sampleStep,
        nearDuplicateThreshold
    );

    ‚Ä¢	Store the result in state as palette, typed as PaletteColor[] or equivalent.

	‚Ä¢	Handle errors gracefully (e.g., show a small error message below the button if something goes wrong).

5. Sorting Options
	‚Ä¢	Add a <select> with label ‚ÄúSort by‚Äù and options:
	‚Ä¢	Population (desc)
	‚Ä¢	Percentage (desc)
	‚Ä¢	Hex value (asc)
	‚Ä¢	Implement a React state variable to track the current sort mode.
	‚Ä¢	Before rendering the palette list, sort a copied array according to this selection:
	‚Ä¢	Population: sort by population descending.
	‚Ä¢	Percentage: sort by percentage descending.
	‚Ä¢	Hex: sort by paletteColor ascending (alphabetical).

6. Palette Display

Assume each palette item has:

    {
        paletteColor: string; // "#RRGGBB"
        textColor: string;    // "#000000" or "#FFFFFF"
        population: number;
        percentage: number;   // 0‚Äì1
    }

Render the result as a responsive grid or flex layout:
	‚Ä¢	Each swatch is a card with:
	‚Ä¢	Background color set to paletteColor.
	‚Ä¢	Text styled with color: textColor.
	‚Ä¢	Contents:
	‚Ä¢	A label ‚ÄúSample text on this color‚Äù
	‚Ä¢	The hex string (e.g., #AABBCC)
	‚Ä¢	Population (e.g., Population: 1234)
	‚Ä¢	Percentage formatted as a percentage (e.g., 28.3%)

You can implement a small reusable PaletteSwatch component (components/PaletteSwatch.tsx) to keep code organized.
	‚Ä¢	If palette is empty or not yet generated, show a friendly message like:
Upload an image and click ‚ÄúGenerate Palette‚Äù to see results.

‚∏ª

üß© TypeScript & Types
	‚Ä¢	Use proper types for component props, state, and callbacks.
	‚Ä¢	Avoid any where possible.
	‚Ä¢	If you port getColorPaletteFromImageElement to TypeScript, put shared interfaces (like PaletteColor) in a shared location (e.g., lib/types.ts or alongside the palette utility) and import them where needed.

‚∏ª

üìÑ README.md Requirements (pnpm + TypeScript)

Update README.md to include:

Title & Description
	‚Ä¢	# ColorPalette
	‚Ä¢	A brief description, e.g.:
ColorPalette is a Next.js + TypeScript playground for extracting dominant color palettes from images using a custom color analysis utility.

Prerequisites
	‚Ä¢	Node.js (specify a reasonable minimum version, e.g. 18+)
	‚Ä¢	pnpm is already installed globally
    
Development

    pnpm dev

    Then open http://localhost:3000 in a browser.

Build & Run Production

    pnpm build
    pnpm start

Usage Instructions
	‚Ä¢	Go to the main page.
	‚Ä¢	Upload an image using the file picker.
	‚Ä¢	Adjust:
	‚Ä¢	Palette size
	‚Ä¢	Max resolution
	‚Ä¢	Sample step
	‚Ä¢	Near-duplicate threshold
	‚Ä¢	Click Generate Palette.
	‚Ä¢	Review the resulting swatches:
	‚Ä¢	Background represents the palette color.
	‚Ä¢	Text uses the recommended contrast color (black or white).
	‚Ä¢	Population and percentage indicate frequency.
	‚Ä¢	Use the ‚ÄúSort by‚Äù control to reorder the palette by population, percentage, or hex.

Notes
	‚Ä¢	Image processing happens completely client-side.
	‚Ä¢	The original JavaScript implementation lives in js/getColorPalette.js.
	‚Ä¢	The TypeScript utility (if you created it) should be mentioned here (e.g., lib/getColorPalette.ts).

‚∏ª

üß≠ Instructions to You (Codex)

Now:
	1.	Inspect the current repository structure.
	2.	Initialize a Next.js + TypeScript project configured to use pnpm.
	3.	Create the UI in pages/index.tsx plus any helper components/files.
	4.	Implement or wire up the TypeScript palette utility based on js/getColorPalette.js.
	5.	Add appropriate styles to styles/globals.css (simple & clean).
	6.	Update README.md with all the instructions above.

Do not remove js/getColorPalette.js. Use it as a reference or as a direct interop source.